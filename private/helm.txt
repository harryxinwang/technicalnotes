关于helm代码的vendor目录,我今天尝试了几种方式。确实如你所说,无法成功,主要是各种第三方vendor的package会冲突。可以想象前些日子真是辛苦你了。
然后反思了一下,本质上helm和openshift/origin是两个独立go repo,它们两个里面要打包的vendor目录难免会有冲突(比如golang/protobuf
使用了不同版本)。因此我们无论做什么go程序,最终只能选择一个go repo里的代码做强类型绑定联合编译,另一个只能通过JSON(REST)或stream(UNIX)
等数据交换方式来通信。
因为现在helmservice里已经import了helm的类型,我们不可能再让它引用origin里面的包了,否则有无数潜在的冲突可能。
因此也能理解为什么origin要自己把k8s vendor化了。假如它不这样的化,它所引用的包也可能大量跟非vendor的k8s引用的第三方包冲突。通过更改
vendor里的k8s,它把所有第三方包统一了。
这样看来,helmservice和qy放在不同的repo里本就是正确的选择。
有关helm模版的设计,我有以下想法跟你商量:
1. 我考虑模版设计的最主要目的是3个: a) 方便用户把模版维护在PAAS平台里进行共享; b) 方便用户用模版部署应用; c) 方便用户能够利用现有的helm和
openshift社区的模版。
2. 是否可以考虑只是把helm模版转化成openshift模版, 最终都通过openshift模版来部署,而不用tiller的服务部署。
这样的好处是UI不需要对接tiller的接口了。UI只需要实现一个Import功能,调用REST服务将模版转化成openshift模版存储。剩下的部署功能,目前UI在
做Openshift模版时已经实现了。
不过这块儿你比我熟悉的多,还是你来决定吧。大概调tiller的接口也不复杂,我们也可以简化一下,只让UI对接最基本的几个接口,能实现读取参数,和部署
两个功能就足够了。
